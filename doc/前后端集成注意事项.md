# 前后端集成注意事项（挂号模块与账户）

本文档旨在为后续开发者提供前后端集成时的统一规范、常见问题与调试步骤，重点针对挂号（registration）与账户（auth）相关功能。

## 一、接口约定
- 所有 API 返回统一 JSON 结构：
  - 成功：{ success: true, data: ..., message?: '...' }
  - 失败：{ success: false, message: '错误描述', code?: 400 }
- HTTP 状态码与业务状态分离：
  - 基本网络/鉴权错误使用合适 HTTP 状态码（401/403/500），并在 body 中包含 success=false 与 message。

## 二、前端请求规范（微信小程序示例）
- 使用统一封装 `app/utils/request.js`：
  - 自动附带 Content-Type
  - 将非 200/201 或后端返回 success=false 视为错误并 reject
  - network error 返回 { code: 0, error }
- 请求示例：
  - POST /api/registration/create
    payload: { account_id, department_id, doctor_id, date, slot, note }
  - 前端使用：
    const { request } = require('../../utils/request');
    await request({ url: '/api/registration/create', method: 'POST', data: payload });

## 三、后端错误处理要求
- 在 `server.js` 中加入 CORS（本地调试）和全局错误处理中间件，保证任何未捕获异常都返回 JSON，避免返回 HTML 错误页导致前端无法解析。
- Controller 层应尽早校验参数并抛出可读的业务错误（400），Service 层捕获 DB/事务错误并抛出/记录。
- 统一异常格式：{ success: false, message: '...' }

## 四、挂号（registration）模块注意点
- 必须在事务内对 `doctor_availability` 使用行级锁（SELECT ... FOR UPDATE）以防超卖。
- 若 availability 不存在，服务可根据策略创建（或返回 404，视业务要求）。
- 当 booked < capacity 时：更新 booked++ 并创建 orders (status='confirmed')。
- 当已满时：创建 orders (status='waiting', is_waitlist=true)。候补队列按 created_at 升序处理。
- 取消 confirmed 后需：booked--，并尝试提升候补（在同一事务或新事务中，对等待订单加锁并提升）。

## 五、账户（Auth）与挂号连接
- 挂号请求必须关联合法的 account_id（推荐由后端根据 token 解析，不建议前端直接传 account_id）。
- 建议实现：前端登录后存储 token（JWT），每次请求在 header 中携带 Authorization: Bearer <token>，后端在中间件中解析并把 userId 注入 req.user。
- 当前实现临时读取 `account_id`（wx.getStorageSync），但这是不安全的：后续请改为基于 token 的鉴权。

## 六、常见问题与解决（快速排查）
- 前端无法接收到错误信息（常见原因）：
  - 后端返回 HTML 错误页（Express 默认） —— 解决：添加 JSON 全局错误处理中间件；
  - CORS 限制或本地地址错误 —— 检查 `BASE_URL` 与 server 是否可达；
  - 网络或防火墙（本机监听 127.0.0.1 与外部连接问题） —— server.listen 使用 0.0.0.0 以支持其他设备访问。
- 并发超额预约：检查是否在事务中对 availability 行做了 FOR UPDATE。若没有则会出现超卖。

## 七、调试建议
- 使用 `console.error` 在后端打印完整错误堆栈并查看运行日志（在 dev 环境可打印）。
- 在小程序端，使用 `console.log` 与 `wx.showToast` 快速展示错误信息；可在 request.reject 时把完整 err 打印。
- 本地调试：确保 `docker-compose` 或 Node 进程监听在 `0.0.0.0:3000`，并把 `app/utils/request.js` 的 `BASE_URL` 指向你的主机 IP（例如 http://192.168.0.10:3000）。

## 八、开发流程建议（模版）
1. 设计接口与契约（请求字段、返回结构、错误码）并记录在 `doc/API文档.md`。
2. 后端先实现 Controller + Service 的基础逻辑并写单元测试（Service 层对事务/并发有测试）；
3. 后端实现统一错误处理中间件与鉴权中间件；
4. 前端使用统一 request 工具并对错误进行友好提示；
5. 做端到端测试（前端->后端），同时检查 DB 行为（是否出现超额、事务是否一致）；
6. 编写并保存集成调试步骤在该文档中，便于下次重现。

## 九、后续改进要点
- 将 account_id 的来源从前端缓存改为后端鉴权解析，避免伪造；
- 在挂号创建接口加入幂等 key，防止重复提交造成超卖；
- 增加 order_history 记录订单状态变化并在取消/提升时写日志；
- 补充通知系统（notifications 表 + MQ）并实现重试策略。

---

若你希望，我可以：
- 将 `registrationController.updateStatus` 改为调用 `registrationService.cancelRegistration` 并在取消时写入 `order_history`；
- 或者把文档翻译为英文并加入具体调试命令脚本。

## 十、数据库初始化与重置（针对本仓库）

- 我们在 `docker-compose.yml` 中已将本地 `./sql` 目录挂载到 MySQL 容器的 `/docker-entrypoint-initdb.d`。MySQL 官方镜像会在**首次初始化容器时**自动执行该目录内的 `*.sql` 或 `*.sh` 文件以完成建表与初始数据导入。
- 如果你已经启动过 mysql 服务且 `mysql-data` 卷中已有数据，MySQL 将不会重复执行 init SQL。若要强制重新执行初始化：
  1. 停止并移除容器：
    ```powershell
    docker-compose down
    ```
  2. 删除数据卷（注意：将丢失现有数据库）：
    ```powershell
    docker volume rm HospitalManage_mysql-data
    # 或者使用实际卷名，可通过 `docker volume ls` 查看`。
    ```
  3. 再次构建并启动：
    ```powershell
    docker-compose up --build
    ```
  4. 检查 MySQL 日志，确认 `init.sql` 已被执行并创建 `accounts`、`orders` 等表。

- 若不想删除整个数据卷，也可以手动在容器内执行 SQL：
  1. 将 SQL 复制到容器或直接使用 mysql 客户端：
    ```powershell
    docker exec -i hospital-mysql mysql -uroot -p123456 hospital < ./sql/init.sql
    ```
  2. 检查表是否创建：
    ```powershell
    docker exec -it hospital-mysql mysql -uroot -p123456 -e "SHOW TABLES IN hospital;"
    ```

## 十一、快速验证步骤
1. 启动容器：`docker-compose up --build`。
2. 进入 MySQL 容器日志：`docker logs -f hospital-mysql`，检查是否执行了 init 脚本。
3. 若 `accounts` 表不存在，按上面说明重建或手动导入 SQL。
4. 在后端容器中确保 `backend/config/default.js` 的 DB_* 环境变量与 docker-compose 一致（已在 compose 中设置）。

